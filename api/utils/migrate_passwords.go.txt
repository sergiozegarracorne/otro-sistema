// migrate_passwords.go
package main

import (
	"fmt"
	"go-login/config"
	"log"

	"golang.org/x/crypto/bcrypt"
)

func main() {
	fmt.Println("üöÄ Iniciando migraci√≥n de contrase√±as...")

	// 1. Conectamos a la base de datos
	config.ConnectDB()

	// 2. Seleccionamos todos los usuarios que tienen contrase√±a en texto plano
	rows, err := config.DB.Query("SELECT idx, paz FROM tbl_user_2025 WHERE ruc ='10203040500'")
	if err != nil {
		log.Fatal("‚ùå Error al consultar usuarios:", err)
	}
	defer rows.Close()

	var count int
	for rows.Next() {
		var userIDX int
		var plainPAZ string

		// 3. Leemos el ID y la contrase√±a de cada usuario
		err := rows.Scan(&userIDX, &plainPAZ)
		if err != nil {
			log.Printf("‚ö†Ô∏è Error al leer fila de usuario ID %d: %v", userIDX, err)
			continue
		}

		// 4. Generamos el hash de la contrase√±a con bcrypt
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(plainPAZ), bcrypt.DefaultCost)
		fmt.Println(hashedPassword)
		if err != nil {
			log.Printf("‚ö†Ô∏è Error al hashear contrase√±a para usuario ID %d: %v", userIDX, err)
			continue
		}

		// 5. Actualizamos la base de datos con el nuevo hash
		_, err = config.DB.Exec("UPDATE tbl_user_2025 SET paz = ? WHERE idx = ?", string(hashedPassword), userIDX)
		if err != nil {
			log.Printf("‚ö†Ô∏è Error al actualizar contrase√±a para usuario ID %d: %v", userIDX, err)
			continue
		}

		fmt.Printf("‚úÖ Usuario ID %d migrado correctamente.\n", userIDX)
		count++
	}

	if err = rows.Err(); err != nil {
		log.Fatal("‚ùå Error durante el recorrido de filas:", err)
	}

	fmt.Printf("\nüéâ Migraci√≥n completada. %d contrase√±as fueron hasheadas y actualizadas.\n", count)
	fmt.Println("üîí Ahora puedes borrar este archivo (migrate_passwords.go) y usar tu login de forma segura.")
}
